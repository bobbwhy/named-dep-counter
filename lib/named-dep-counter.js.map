{"version":3,"sources":["../src/named-dep-counter.js"],"names":["NamedDepCounter","name","_name","_deps","_depsFulfilled","_depsFulfilledIndex","_depsIndex","_count","_onComplete","_self","self","length","dependencies","depList","append","Array","isArray","Object","keys","Error","_key","_l","i","adj","depName","deps","depsIndex","_remainingCount","currentDepsIndex","concat","key","_notReady","ind","console","log","push","_complete","filter","dep","indexOf","callback","mark","call"],"mappings":"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","file":"named-dep-counter.js","sourcesContent":["\nclass NamedDepCounter { \n\n  constructor(name) { \n    this._name = name;\n    this._deps = [];\n    this._depsFulfilled = [];\n    this._depsFulfilledIndex = {};\n    this._depsIndex = {};\n    this._count = -1;\n    this._onComplete =()=>true;\n    this._self = true;\n  }\n\n  /**\n   * get or set 'self' aka context.\n   * This will be the first argument\n   * to be passed into the onMark and onComplete\n   * callbacks.  If this is not set, then \n   * that argument is this NamedDepCounter\n   * @param  {object | null} self \n   * @return {null | object}  \n   */\n  self(self=null) { \n    if (self === null) return this._self === true ? this : this._self;\n\n    this._self = self; \n  } \n\n  /**\n   * Show the number of dependencies to be marked complete\n   * @return {uint}\n   */\n  count() { \n    return this._deps.length;\n  }\n\n  /**\n   * Show the dependencies that have been fulfilled\n   * @return {array} the names of the fulfilled dependecies.\n   */\n  current() { \n    return this._depsFulfilled;\n  }\n\n  /**\n   * show the number of dependencies that have been fulfilled\n   * @return {uint}\n   */\n  currentCount() { \n    return this._depsFulfilled.length;\n  }\n\n  /**\n   * get or set the dependencies for this \n   * NamedDepCounter.  <br>\n   * If getting, ALL dependencies will be shown\n   * regardless of whether or not they are fulfilled.\n   * <br>\n   * If setting, you can choose to merge the new \n   * dependencies with any existing ones or to overwrite\n   * any existing dependencies with the new ones you are setting.\n   * \n   * @param  {Array | String | Object | null} \n   *          depList the deps to be set.  If null.. return existing deps\n   * \n   * @param {Boolean} append.  If true, append these else overwrite.\n   * @return {Array | null} if getting, the list of dependencies.. else null\n   */\n  deps(...p) { \n    return this.dependencies(...p);\n  }\n\n  /**\n   * get or set the dependencies for this \n   * NamedDepCounter.  <br>\n   * If getting, ALL dependencies will be shown\n   * regardless of whether or not they are fulfilled.\n   * <br>\n   * If setting, you can choose to merge the new \n   * dependencies with any existing ones or to overwrite\n   * any existing dependencies with the new ones you are setting.\n   * \n   * @param  {Array | String | Object | null} \n   *          depList the deps to be set.  If null.. return existing deps\n   * \n   * @param {Boolean} append.  If true, append these else overwrite.\n   * @return {Array | null} if getting, the list of dependencies.. else null\n   */\n  dependencies(depList=null, append=false) { \n    if (depList === null) return this._deps;\n\n    if (Array.isArray(depList) === false) { \n      switch(typeof depList) { \n        case 'object': \n          depList = Object.keys(depList);\n        break;\n        case 'string': \n          depList = [depList];\n        break;\n        default:\n          throw new Error(\n            `NamedDepCounter ${this._key} Error: \n             Tried to add invalid dependency list to counter.\n             Please try again with types, object, array or string.`\n          )\n      }\n    }\n    \n    const _l = depList.length;\n    let i = 0;\n    const adj = append === false ? 0 : this._deps.length;\n    let depName;\n    const deps = [];\n    const depsIndex = {};\n    for ( ; i !== _l; i++ ) { \n      depName = depList[i];\n      deps[i] = depName;\n      depsIndex[depName] = i + adj;\n    }\n\n    if (append === false) { \n      this._deps = deps;\n      this._depsIndex = depsIndex;\n      this._count = _l;\n      this._remainingCount = _l;\n      return\n    }\n\n    const currentDepsIndex = this._depsIndex;\n    this._deps = this._deps.concat(deps);\n\n    this._depsIndex = { ...currentDepsIndex, ...depsIndex };\n    this._count+=_l;\n    this._remainingCount = this._count - this._depsFulfilled.length;\n  }\n\n  /**\n   * mark a named dependency as complete\n   * @param  {string} key\n   * @return {Boolean} true is a dep is marked, false if \n   * the dep was already marked or does not exist.\n   */\n  mark(key) { \n    if (this._count === -1) return this._notReady();\n    const ind = this._depsIndex[key]\n    if (typeof ind === 'undefined') { \n      console.log(\n        `NamedDepCounter ${this._key} Warning: \n         tried to mark a non-existent dependency ${key} as complete`\n      );\n      return false;\n    }\n    if (key in this._depsFulfilledIndex === true) return false;\n\n    this._depsFulfilled.push(this._deps[this._depsIndex[key]]);\n    this._depsFulfilledIndex[key] = true;\n    this._remainingCount--;\n    if (this._remainingCount === 0) return this._complete();\n    return true;\n  }\n\n  /**\n   * set or get the name of this namedDepCounter\n   * @param  {string | null} name\n   * @return {null | string} null if setting, string if getting.\n   */\n  name(name=null) { \n    if (name === null) return this._name;\n\n    this._name = name;\n  }\n\n  /**\n   * are all the deps complete?\n   * @return {Boolean} true if complete, false if otherwise.\n   */\n  ready() { \n    return this._remainingCount === 0;\n  }\n\n  /**\n   * Show the list of deps waiting to be marked complete.\n   * @return {array} \n   */\n  remaining() { \n    const { _depsFulfilled } = this;\n    return this._deps.filter((dep)=>_depsFulfilled.indexOf(dep)===-1);\n  };\n\n  /**\n   * show number of deps waiting to be completed.\n   * @return {uint}\n   */\n  remainingCount() { \n    return this._count - this._depsFulfilled.length;\n  }\n\n  /**\n   * mark all dependencies as NOT complete.. reset all counts.\n   * @return {null}\n   */\n  reset() { \n    this._remainingCount = this._deps.length;\n    this._depsFulfilled = [];\n    this._depsFulfilledIndex = {};\n  }\n\n  /**\n   * add a callback to be run when all the deps are complete\n   * @param  {Function} callback \n   * @return {null}\n   */\n  onComplete(callback) { \n    const self = this.self();\n    this._onComplete =()=>callback(self);\n  }\n\n  /**\n   * add a callback to be run when a dep is marked complete.\n   * @param  {Function} callback\n   * @return {null}\n   */\n  onMark(callback) { \n    const mark = this.mark;\n    const self = this.self();\n    this.mark = function(key) { \n      if (mark.call(this, key) === false) return;\n\n      callback(self, key);\n    }\n  }\n\n  /**\n   * run when all deps are complete\n   * @private\n   * @return {null}\n   */\n  _complete() { \n    const self = this.self()\n    this._onComplete(this);\n  }\n\n  /**\n   * run when this NamedDepCounter is not ready \n   * and mark was called.\n   * @return {null}\n   */\n  _notReady() { \n    console.log(\n      `NamedDepCounter ${this._key} is not ready.\n       Please insert some dependency names with \n       NamedDepCounter.dependencies([array of dependencies]);`\n    );\n  }\n\n}\n\nexport default NamedDepCounter;\n"]}